---
title: "SPatially aUTomatic deNoising for Ims toolKit (SPUTNIK)"
output:
  html_document:
    theme: readable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Welcome to SPUTNIK Github Page!
SPUTNIK is a filter tool for Mass Spectrometry Imaging (MSI) data. It is designed
to identify and remove the mass spectral peaks that are spatially unrelated with
the sample of interest. Often MSI data contain signal generated by the analytical
technique used for the ion desorption. For instance, DESI-MSI data can contain
solvent-related signals, or, in the case of MALDI-MSI, matrix-related signal can
be part of the data.
These signals are non-informative about the molecular content of the analyzed
sample, and can interfere with the statistical analysis of the data. Furthermore,
the presence of these signals makes the dimensionality of the data uselessly big.
SPUTNIK uses three classes of filters to identify and remove these types of
signals.

## Global reference filter

The first family of filters, called *general similarity filters*, uses the expected
location of the sample (ROI) to determine if a signal is informative or not.
Simple similarity measures between the ROI, or a continuous reference signal
representing the area occupied by the sample, and the images generated by the
peak signals are used to determine whether a peak is informative.
The continuous reference and ROI images can be calculated from the MSI data or imported.
There are four methods to calculate the continuous reference:

* "sum": sum of all the peak intensities
* "mean": non-zero mean of all the peak intensities
* "median": non-zero median of all the peak intensities
* "pca": first principal component scores are assigned to the pixels intensities

There are also four methods to calculate the ROI:

* "otsu": the continuous reference (calculated using one of the previous methods)
is binarized using Otsu's thresholding
* "kmeans": k-means with 2 clusters is applied to the entire MSI dataset to
generate a binary ROI
* "kmeans2": k-means with N (N > 2) clusters is applied to the entire MSI dataset
to generate a segmentation of the image. Then, the clusters are merged into sample-related
and sample-unrelated.
* "supervised": the user annotates two areas of the image as sample-unrelated and
sample-related. A linear SVM, trained on those spectra, is used to assign the
labels to all the remaining pixels.

For instance, continuous reference and ROI from Rompp et al. MALDI-MSI
dataset are calculated as follows.

```{r load SPUTNIK}
library(SPUTNIK)
```

First load the example MALDI-MSI data
```{r load Rompp}
bladderMALDI <- bladderMALDIRompp2010() 
```

Then, create the msiDataset object using the `msiDataset` command, and apply the
normalization and log2-transformation
```{r create msiDataset}
msiX <- msiDataset(values = bladderMALDI,
                   mz = attr(bladderMALDI, 'mass'),
                   rsize = attr(bladderMALDI, 'size')[1],
                   csize = attr(bladderMALDI, 'size')[2])
msiX <- normIntensity(msiX, 'PQN')
msiX <- varTransform(msiX, 'log2')
```

The `refAndRoiImages` command generates the continuous reference and ROI
```{r ref and roi}
ref_roi <- refAndROIimages(msiData = msiX, refMethod = "sum", roiMethod = "otsu")
```

Both the continuous reference and ROI can be plotted using the `plot` command
```{r plot ref}
plot(ref_roi$Reference)
```
```{r plot roi}
plot(ref_roi$ROI)
```

The sum of the peaks intensities does not show clearly the area occupied by the
sample. Therefore, we can use k-means to extract the ROI, setting the
`roifMethod` to `kmeans2`.

```{r ref and roi 2}
ref_roi <- refAndROIimages(msiData = msiX, refMethod = "sum", roiMethod = "kmeans2")
```

Now the images are positively correlated with the sample region.
```{r plot ref 2}
plot(ref_roi$Reference)
```
```{r plot roi 2}
plot(ref_roi$ROI)
```

Often the ROI contains several scattered pixels, as result of the presence of noise
in the original data. The isolated pixels can be removed through the `removeSmallObjects`
command. Now we remove all the connected objects smaller than 5 pixels.

```{r remove small objects}
ref_roi$ROI <- removeSmallObjects(ref_roi$ROI, threshold = 5)
plot(ref_roi$ROI)
```

The global reference filter uses the similarity between the peak intensity image
and the continuous reference or the binary ROI. In this case, we calculate the
normalized mutual information (NMI) with the ROI

```{r gpf}
gpf <- globalPeaksFilter(msiData = msiX, referenceImage = ref_roi$ROI,
                         method = 'nmi')
```

Then, we can apply the filter to remove the uninformative peaks.

```{r apply gpf}
msiX <- applyPeaksFilter(msiX, gpf)
print(dim(getIntensityMat(msiX)))
```

We can check the effect of filtering by plotting the RGB image corresponding to
the scores of the first 3 principal components. This gives a qualitative idea of
the spatial structures present in the dataset

```{r pca image}
pca <- prcomp(getIntensityMat(msiX), center = TRUE, scale. = TRUE)
pcaRGB <- matrix(NA, prod(getShapeMSI(msiX)), 3)
for (i in 1:3)
  pcaRGB[, i] <- (pca$x[, i] - min(pca$x[, i])) / (max(pca$x[, i]) - min(pca$x[, i]))
pcaRGB <- rgb(pcaRGB)
plot(as.raster(matrix(pcaRGB, getShapeMSI(msiX)[1], getShapeMSI(msiX)[2])),
     interpolate = F)
```
