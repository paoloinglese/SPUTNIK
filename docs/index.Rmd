---
title: "SPatially aUTomatic deNoising for Ims toolKit (SPUTNIK)"
output:
  html_document:
    theme: readable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Welcome to SPUTNIK Github Page!
SPUTNIK is a filter tool for Mass Spectrometry Imaging (MSI) data. It is designed
to identify and remove the mass spectral peaks that are spatially unrelated with
the sample of interest. Often MSI data contain signal generated by the analytical
technique used for the ion desorption. For instance, DESI-MSI data can contain
solvent-related signals, or, in the case of MALDI-MSI, matrix-related signal can
be part of the data.
These signals are non-informative about the molecular content of the analyzed
sample, and can interfere with the statistical analysis of the data. Furthermore,
the presence of these signals makes the dimensionality of the data uselessly big.
SPUTNIK uses three classes of filters to identify and remove these types of
signals.

# Filters

## Global reference filter

The first family of filters, called *general similarity filters*, uses the expected
location of the sample (ROI) to determine if a signal is informative or not.
Simple similarity measures between the ROI, or a continuous reference signal
representing the area occupied by the sample, and the images generated by the
peak signals are used to determine whether a peak is informative.
The continuous reference and ROI images can be calculated from the MSI data or
imported.
There are four methods to calculate the continuous reference:

* "sum": sum of all the peak intensities
* "mean": non-zero mean of all the peak intensities
* "median": non-zero median of all the peak intensities
* "pca": first principal component scores are assigned to the pixels intensities

There are also four methods to calculate the ROI:

* "otsu": the continuous reference (calculated using one of the previous methods)
is binarized using Otsu's thresholding
* "kmeans": k-means with 2 clusters is applied to the entire MSI dataset to
generate a binary ROI
* "kmeans2": k-means with N (N > 2) clusters is applied to the entire MSI dataset
to generate a segmentation of the image. Then, the clusters are merged into
sample-related and sample-unrelated.
* "supervised": the user annotates two areas of the image as sample-unrelated and
sample-related. A linear SVM, trained on those spectra, is used to assign the
labels to all the remaining pixels.

For instance, continuous reference and ROI from Rompp et al. MALDI-MSI
dataset are calculated as follows.

```{r load SPUTNIK}
library(SPUTNIK)
```

First let's load the example MALDI-MSI data

```{r load Rompp}
bladderMALDI <- bladderMALDIRompp2010() 
```

Then, we create the dataset object using the `msiDataset` command:

```{r create msiDataset}
msiX <- msiDataset(values = bladderMALDI,
                   mz = attr(bladderMALDI, 'mass'),
                   rsize = attr(bladderMALDI, 'size')[1],
                   csize = attr(bladderMALDI, 'size')[2])
```

The first thing to do is to plot the image of the number of detected peaks and total ion count (TIC). These
image are useful to capture the spatial location of the sample, as we expect its spectra
to contain more ions or more intense signals:

```{r TIC}
plot(msiX@totalioncount)
```

```{r numDetectedMSI}
plot(msiX@numdetected)
```
Unfortunately, in this case, it seems that more ions with higher TIC are detected _outside_ of the tissue,
***we will need to remember this in the following steps***.

Now we can normalize and apply the variable stabilizing transformation:

```{r norm}
msiX <- normIntensity(msiX, 'PQN')
msiX <- varTransform(msiX, 'log2')
```

## Generating reference image and sample region-of-interest (ROI)

The `refAndRoiImages` command generates the continuous reference and ROI.

***NOTE***: since the number of detected ions is greater outside of the tissue,
we need to set the argument `alignToReference` to FALSE:

```{r ref and roi}
ref_roi <- refAndROIimages(msiData = msiX, refMethod = "pca", roiMethod = "otsu",
                           alignToReference = FALSE)
```

Both the continuous reference and ROI can be plotted using the `plot` command

```{r plot ref}
plot(ref_roi$Reference)
```
```{r plot roi}
plot(ref_roi$ROI)
```

The sum of the peaks intensities does not show clearly the area occupied by the
sample. Therefore, we can use k-means to extract the ROI, setting the
`roifMethod` to `kmeans2`.

```{r ref and roi 2}
ref_roi <- refAndROIimages(msiData = msiX, refMethod = "pca", roiMethod = "kmeans2",
                           alignToReference = FALSE, sampleReference = "detected")
```

Now the images are positively correlated with the sample region.
```{r plot ref 2}
plot(ref_roi$Reference)
```
```{r plot roi 2}
plot(ref_roi$ROI)
```

Often the ROI contains several scattered pixels, as result of the presence of noise
in the original data. The isolated pixels can be removed through the `removeSmallObjects`
command. Now we remove all the connected objects smaller than 5 pixels.

```{r remove small objects}
ref_roi$ROI <- removeSmallObjects(ref_roi$ROI, threshold = 5)
plot(ref_roi$ROI)
```

The global reference filter uses the similarity between the peak intensity image
and the continuous reference or the binary ROI. In this case, we calculate the
normalized mutual information (NMI) with the ROI

```{r gpf}
gpf <- globalPeaksFilter(msiData = msiX, referenceImage = ref_roi$ROI,
                         method = 'nmi', threshold = 0, cores = 4)
```

Then, we can apply the filter to remove the uninformative peaks.

```{r apply gpf}
msiX <- applyPeaksFilter(msiX, gpf)
print(dim(getIntensityMat(msiX)))
```

We can check the effect of filtering by plotting the RGB image corresponding to
the scores of the first 3 principal components. This gives a qualitative idea of
the spatial structures present in the dataset

```{r pca image}
pca.img <- PCAImage(msiX)
plot(pca.img, interpolate = F)
```

```{r TIC.after}

tic.img <- totalIonCountMSI(msiX)
plot(tic.img)

```


## Pixel count filter

Pixel count filter overcomes the problems related with the standard approach of
removing peaks that are found in less than a certain number of pixels (thresholding).
This methodology does not take into account of the spatial structure of the peak
signals and therefore can remove important, although localized in small regions,
signals.
Pixel count filter allows the user to define the minimum number of connected
pixels for a peak signal to consider it informative. Also, through three levels
of *aggressiveness*, it compares the size of the connected signal pixels inside
and outside the sample ROI.
Now we define a new `msiDataset` object using the original MALDI-MSI data

```{r create msiDataset cpf}
msiX <- msiDataset(values = bladderMALDI,
                   mz = attr(bladderMALDI, 'mass'),
                   rsize = attr(bladderMALDI, 'size')[1],
                   csize = attr(bladderMALDI, 'size')[2])
msiX <- normIntensity(msiX, 'PQN')
msiX <- varTransform(msiX, 'log2')
```

We extract the sample-related ROI, as done in the previous section

The `refAndRoiImages` command generates the continuous reference and ROI, and we
remove the connected objects smaller than 5 pixels
```{r ref and roi cpf}
ref_roi <- refAndROIimages(msiData = msiX, refMethod = "sum", roiMethod = "kmeans2")
ref_roi$ROI <- removeSmallObjects(ref_roi$ROI, threshold = 5)
plot(ref_roi$ROI)
```

and we define the filter, requesting the smallest number of connected signal pixels
to be larger than 9. Also, we set the aggressiveness to 1, through the parameter
`agressive = 1`. In this way, we request that the largest connected object outside
the ROI is smaller than the largest one within the ROI

```{r cpf}
cpf <- countPixelsFilter(msiData = msiX, roiImage = ref_roi$ROI, minNumPixels = 9,
                         aggressive = 1)
```

After, we apply the filter and check the RGB image of the first three principal
components scores

```{r apply cpf}
msiX <- applyPeaksFilter(msiX, cpf)
print(dim(getIntensityMat(msiX)))
```

```{r pca image cpf}
pca <- prcomp(getIntensityMat(msiX), center = TRUE, scale. = TRUE)
pcaRGB <- matrix(NA, prod(getShapeMSI(msiX)), 3)
for (i in 1:3)
  pcaRGB[, i] <- (pca$x[, i] - min(pca$x[, i])) / (max(pca$x[, i]) - min(pca$x[, i]))
pcaRGB <- rgb(pcaRGB)
plot(as.raster(matrix(pcaRGB, getShapeMSI(msiX)[1], getShapeMSI(msiX)[2])),
     interpolate = F)
```

# Complete spatial randomness

The third class of filters use the complete spatial randomness tests to determine
whether the - binarized - peak signal images represent a random point pattern.
There are two available tests: *Clark-Evans* and *Kolmogorov-Smirnov*.
We show here how to apply the *Clark-Evans* test on the MALDI-MSI data.

Again,

```{r create msiDataset csr}
msiX <- msiDataset(values = bladderMALDI,
                   mz = attr(bladderMALDI, 'mass'),
                   rsize = attr(bladderMALDI, 'size')[1],
                   csize = attr(bladderMALDI, 'size')[2])
msiX <- normIntensity(msiX, 'PQN')
msiX <- varTransform(msiX, 'log2')
```

Now we run the filter

```{r csr}
csr <- CSRPeaksFilter(msiData = msiX, method = 'ClarkEvans', verbose = T)
```

By default, `CSRPeaksFilter` calculates the p-values for the selected test, and
applies the Bonferroni multiple testing correction. The adjusted p-values are
denoted q-values. We can use the 0.05 threshold to define the peak filter.
It is important to notice that the Clark-Evans test does not distinguish between
signals localized outside or within the ROI, so it is better to run it after the
global reference filter.

```{r csr filter}
csrFilter <- createPeaksFilter(which(csr$q.value < 0.05))
```

We can apply the filter and plot the RGB image

```{r apply csr}
msiX <- applyPeaksFilter(msiX, csrFilter)
print(dim(getIntensityMat(msiX)))
```

```{r pca image csr}
pca <- prcomp(getIntensityMat(msiX), center = TRUE, scale. = TRUE)
pcaRGB <- matrix(NA, prod(getShapeMSI(msiX)), 3)
for (i in 1:3)
  pcaRGB[, i] <- (pca$x[, i] - min(pca$x[, i])) / (max(pca$x[, i]) - min(pca$x[, i]))
pcaRGB <- rgb(pcaRGB)
plot(as.raster(matrix(pcaRGB, getShapeMSI(msiX)[1], getShapeMSI(msiX)[2])),
     interpolate = F)
```
